(($) ->

  # Underscore.string
  # Version 1.1.4
  (->

    # ------------------------- Baseline setup ---------------------------------

    # Establish the root object, "window" in the browser, or "global" on the server.
    str_repeat = (i, m) ->
      o = []

      while m > 0
        o[--m] = i
      o.join ""
    defaultToWhiteSpace = (characters) ->
      return _s.escapeRegExp(characters)  if characters
      "\\s"
    root = this
    nativeTrim = String::trim
    parseNumber = (source) ->
      source * 1 or 0

    _s =
      startsWith: (str, starts) ->
        str.length >= starts.length and str.substring(0, starts.length) is starts

      endsWith: (str, ends) ->
        str.length >= ends.length and str.substring(str.length - ends.length) is ends

      trim: (str, characters) ->
        return nativeTrim.call(str)  if not characters and nativeTrim
        characters = defaultToWhiteSpace(characters)
        str.replace new RegExp("^[" + characters + "]+|[" + characters + "]+$", "g"), ""

      ltrim: (str, characters) ->
        characters = defaultToWhiteSpace(characters)
        str.replace new RegExp("^[" + characters + "]+", "g"), ""

      rtrim: (str, characters) ->
        characters = defaultToWhiteSpace(characters)
        str.replace new RegExp("[" + characters + "]+$", "g"), ""


    # CommonJS module is defined
    if typeof window is "undefined" and typeof module isnt "undefined"

      # Export module
      module.exports = _s

    # Integrate with Underscore.js
    else if typeof root._ isnt "undefined"
      root._.mixin _s

    # Or define it
    else
      root._ = _s
  )()

  # Generated by CoffeeScript 1.6.2
  #
  #  clientside HAML compiler for Javascript and Coffeescript (Version 5)
  #
  #  Copyright 2011-12, Ronald Holshausen (https://github.com/uglyog)
  #  Released under the MIT License (http://www.opensource.org/licenses/MIT)
  #
  (->
    flatten = (arr) ->
      arr.reduce ((a, b) ->
        a.concat b
      ), []

    e = undefined
    t = undefined
    n = undefined
    r = undefined
    i = undefined
    s = undefined
    o = undefined
    u = undefined
    a = undefined
    f = undefined
    l = {}.hasOwnProperty
    c = (e, t) ->
      r = ->
        @constructor = e
      for n of t
        l.call(t, n) and (e[n] = t[n])
      r:: = t::
      e:: = new r
      e.__super__ = t::
      e

    a = this
    r =
      escapeHTML: (e) ->
        String(e or "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace /'/g, "&#39;"

      perserveWhitespace: (e) ->
        t = undefined
        n = undefined
        r = undefined
        i = undefined
        r = /<[a-zA-Z]+>[^<]*<\/[a-zA-Z]+>/g
        n = ""
        t = 0
        i = r.exec(e)

        if i
          while i
            n += e.substring(t, i.index)
            n += i[0].replace(/\n/g, "&#x000A;")
            t = i.index + i[0].length
            i = r.exec(e)
          n += e.substring(t)
        else
          n = e
        n

      templateError: (e, t, n, r) ->
        i = undefined
        s = undefined
        s = r + " at line " + e + " and character " + t + ":\n" + n + "\n"
        i = 0

        while i < t - 1
          s += "-"
          i++
        s += "^"
        s

      generateElementAttributes: (e, t, n, r, i, s, o, u, a) ->
        f = undefined
        c = undefined
        h = undefined
        p = undefined
        d = undefined
        v = undefined
        m = undefined
        g = undefined
        y = undefined
        b = undefined
        c = {}
        c = @combineAttributes(c, "id", t)
        n.length > 0 and n[0].length > 0 and (c = @combineAttributes(c, "class", n))

        if i?
          for f of i
            continue  unless l.call(i, f)
            b = i[f]
            c = @combineAttributes(c, f, b)
        if r?
          try
            g = r.call(e, e)
            g? and (y = null
            (if g.id? then y = g.id else g.get and (y = g.get("id")))
            c = @combineAttributes(c, "id", y)
            h = null
            (if g["class"] then h = g["class"] else g.get and (h = g.get("class")))
            c = @combineAttributes(c, "class", h)
            )
          catch w
            throw p = w
            haml.HamlRuntime.templateError(o, u, a, "Error evaluating object reference - " + p)
        if s?
          try
            v = s.call(e, e)
            if v?
              v = @_flattenHash(null, v)
              for f of v
                continue  unless l.call(v, f)
                b = v[f]
                c = @combineAttributes(c, f, b)
          catch w
            throw d = w
            haml.HamlRuntime.templateError(o, u, a, "Error evaluating attribute hash - " + d)
        m = ""
        if c
          for f of c
            continue  unless l.call(c, f)
            haml.hasValue(c[f]) and ((if (f is "id" or f is "for") and c[f] instanceof Array then m += " " + f + "=\"" + flatten(c[f]).join("-") + "\"" else (if f is "class" and c[f] instanceof Array then m += " " + f + "=\"" + flatten(c[f]).join(" ") + "\"" else m += " " + f + "=\"" + haml.attrValue(f, c[f]) + "\"")))
        m

      indentText: (e) ->
        t = undefined
        n = undefined
        n = ""
        t = 0

        while t < e
          n += "  "
          t++
        n

      combineAttributes: (e, t, n) ->
        r = undefined
        haml.hasValue(n) and ((if t is "id" and n.toString().length > 0 then (if e and e.id instanceof Array then e.id.unshift(n) else (if e and e.id then e.id = [e.id, n] else (if e then e.id = n else e = id: n))) else (if t is "for" and n.toString().length > 0 then (if e and e["for"] instanceof Array then e["for"].unshift(n) else (if e and e["for"] then e["for"] = [e["for"], n] else (if e then e["for"] = n else e = for: n))) else (if t is "class" then (r = []
        (if n instanceof Array then r = r.concat(n) else r.push(n))
        (if e and e["class"] then e["class"] = e["class"].concat(r) else (if e then e["class"] = r else e = class: r))
        ) else t isnt "id" and (e or (e = {})
        e[t] = n
        )))))
        e

      _flattenHash: (e, t) ->
        n = undefined
        r = undefined
        i = undefined
        s = undefined
        o = undefined
        u = undefined
        a = undefined
        f = undefined
        a = {}
        if @_isHash(t)
          for n of t
            continue  unless l.call(t, n)
            f = t[n]
            s = []
            e? and s.push(e)
            s.push(n)
            i = s.join("-")
            r = @_flattenHash(i, f)

            if @_isHash(r)
              for o of r
                continue  unless l.call(r, o)
                u = r[o]
                a[o] = u
            else
              a[i] = r
        else
          (if e? then a[e] = t else a = t)
        a

      _isHash: (e) ->
        e? and typeof e is "object" and not (e instanceof Array or e instanceof Date)

    o = ->
      e = (e) ->
        t = undefined
        n = undefined
        r = undefined
        i = this
        @buffer = null
        @bufferIndex = null
        @prevToken = null
        @token = null

        if e.templateId?
          r = document.getElementById(e.templateId)
          throw "Did not find a template with ID '" + e.templateId + "'"  unless r
          @buffer = r.text
          @bufferIndex = 0
        else
          (if e.template? then (@buffer = e.template
          @bufferIndex = 0
          ) else e.templateUrl? and (t = (t, n, r) ->
            throw "Failed to fetch haml template at URL " + e.templateUrl + ": " + n + " " + r

          n = (e) ->
            i.buffer = e
            i.bufferIndex = 0

          jQuery.ajax(
            url: e.templateUrl
            success: n
            error: t
            dataType: "text"
            async: not 1
            beforeSend: (e) ->
              e.withCredentials = not 0
          )
          ))
      e::currentLineMatcher = /[^\n]*/g
      e::tokenMatchers =
        whitespace: /[ \t]+/g
        element: /%[a-zA-Z][a-zA-Z0-9]*/g
        idSelector: /#[a-zA-Z_\-][a-zA-Z0-9_\-]*/g
        classSelector: /\.[a-zA-Z0-9_\-]+/g
        identifier: /[a-zA-Z][a-zA-Z0-9\-]*/g
        quotedString: /[\'][^\'\n]*[\']/g
        quotedString2: /[\"][^\"\n]*[\"]/g
        comment: /\-#/g
        escapeHtml: /\&=/g
        unescapeHtml: /\!=/g
        objectReference: /\[[a-zA-Z_@][a-zA-Z0-9_]*\]/g
        doctype: /!!!/g
        continueLine: /\|\s*\n/g
        filter: /:\w+/g

      e::matchToken = (e) ->
        t = undefined
        e.lastIndex = @bufferIndex
        t = e.exec(@buffer)

        t[0]  if ((if t? then t.index else undefined)) is @bufferIndex

      e::matchMultiCharToken = (e, t, n) ->
        r = undefined
        i = undefined
        unless @token
          r = @matchToken(e)
          if r
            @token = t
            @token.tokenString = (if (i = (if typeof n is "function" then n(r) else undefined))? then i else r)
            @token.matched = r
            @advanceCharsInBuffer(r.length)

      e::matchSingleCharToken = (e, t) ->
        if not @token and @buffer.charAt(@bufferIndex) is e
          @token = t
          @token.tokenString = e
          @token.matched = e
          @advanceCharsInBuffer(1)

      e::getNextToken = ->
        e = undefined
        t = undefined
        n = undefined
        r = undefined
        i = undefined
        s = undefined
        o = undefined
        throw haml.HamlRuntime.templateError(@lineNumber, @characterNumber, @currentLine, "An internal parser error has occurred in the HAML parser")  if isNaN(@bufferIndex)
        @prevToken = @token
        @token = null

        unless @buffer is null or @buffer.length is @bufferIndex
          @initLine()
          unless @token
            t = @buffer.charCodeAt(@bufferIndex)
            n = @buffer.charCodeAt(@bufferIndex + 1)

            if t is 10 or t is 13 and n is 10
              @token =
                eol: not 0
                token: "EOL"

              (if t is 13 and n is 10 then (@advanceCharsInBuffer(2)
              @token.matched = String.fromCharCode(t) + String.fromCharCode(n)
              ) else (@advanceCharsInBuffer(1)
              @token.matched = String.fromCharCode(t)
              ))
              @characterNumber = 0
              @currentLine = @getCurrentLine()
          @matchMultiCharToken(@tokenMatchers.whitespace,
            ws: not 0
            token: "WS"
          )
          @matchMultiCharToken(@tokenMatchers.continueLine,
            continueLine: not 0
            token: "CONTINUELINE"
          )
          @matchMultiCharToken(@tokenMatchers.element,
            element: not 0
            token: "ELEMENT"
          , (e) ->
            e.substring 1
          )
          @matchMultiCharToken(@tokenMatchers.idSelector,
            idSelector: not 0
            token: "ID"
          , (e) ->
            e.substring 1
          )
          @matchMultiCharToken(@tokenMatchers.classSelector,
            classSelector: not 0
            token: "CLASS"
          , (e) ->
            e.substring 1
          )
          @matchMultiCharToken(@tokenMatchers.identifier,
            identifier: not 0
            token: "IDENTIFIER"
          )
          @matchMultiCharToken(@tokenMatchers.doctype,
            doctype: not 0
            token: "DOCTYPE"
          )
          @matchMultiCharToken(@tokenMatchers.filter,
            filter: not 0
            token: "FILTER"
          , (e) ->
            e.substring 1
          )
          @token or (o = @matchToken(@tokenMatchers.quotedString)
          o or (o = @matchToken(@tokenMatchers.quotedString2))
          o and (@token =
            string: not 0
            token: "STRING"
            tokenString: o.substring(1, o.length - 1)
            matched: o

          @advanceCharsInBuffer(o.length)
          )
          )
          @matchMultiCharToken(@tokenMatchers.comment,
            comment: not 0
            token: "COMMENT"
          )
          @matchMultiCharToken(@tokenMatchers.escapeHtml,
            escapeHtml: not 0
            token: "ESCAPEHTML"
          )
          @matchMultiCharToken(@tokenMatchers.unescapeHtml,
            unescapeHtml: not 0
            token: "UNESCAPEHTML"
          )
          @matchMultiCharToken(@tokenMatchers.objectReference,
            objectReference: not 0
            token: "OBJECTREFERENCE"
          , (e) ->
            e.substring 1, e.length - 1
          )

          if not @token and @buffer and @buffer.charAt(@bufferIndex) is "{"
            i = @bufferIndex + 1
            r = @characterNumber
            s = @lineNumber
            e = 1

            while i < @buffer.length and (e > 1 or @buffer.charAt(i) isnt "}")
              (if @buffer.charAt(i) is "{" then e++ else @buffer.charAt(i) is "}" and e--)
              i++
            if i is @buffer.length
              throw @characterNumber = r + 1
              @lineNumber = s
              @parseError("Error parsing attribute hash - Did not find a terminating \"}\"")
            @token =
              attributeHash: not 0
              token: "ATTRHASH"
              tokenString: @buffer.substring(@bufferIndex, i + 1)
              matched: @buffer.substring(@bufferIndex, i + 1)

            @advanceCharsInBuffer(i - @bufferIndex + 1)
          @matchSingleCharToken("(",
            openBracket: not 0
            token: "OPENBRACKET"
          )
          @matchSingleCharToken(")",
            closeBracket: not 0
            token: "CLOSEBRACKET"
          )
          @matchSingleCharToken("=",
            equal: not 0
            token: "EQUAL"
          )
          @matchSingleCharToken("/",
            slash: not 0
            token: "SLASH"
          )
          @matchSingleCharToken("!",
            exclamation: not 0
            token: "EXCLAMATION"
          )
          @matchSingleCharToken("-",
            minus: not 0
            token: "MINUS"
          )
          @matchSingleCharToken("&",
            amp: not 0
            token: "AMP"
          )
          @matchSingleCharToken("<",
            lt: not 0
            token: "LT"
          )
          @matchSingleCharToken(">",
            gt: not 0
            token: "GT"
          )
          @matchSingleCharToken("~",
            tilde: not 0
            token: "TILDE"
          )
          @token is null and (@token =
            unknown: not 0
            token: "UNKNOWN"
          )
        @token

      e::lookAhead = (e) ->
        t = undefined
        n = undefined
        r = undefined
        i = undefined
        s = undefined
        o = undefined
        u = undefined
        a = undefined
        a = null
        if e > 0
          i = @token
          u = @prevToken
          r = @currentLine
          o = @lineNumber
          n = @characterNumber
          t = @bufferIndex
          s = 0

          a = @getNextToken()  while s++ < e
          @token = i
          @prevToken = u
          @currentLine = r
          @lineNumber = o
          @characterNumber = n
          @bufferIndex = t
        a

      e::initLine = ->
        if not @currentLine and @currentLine isnt ""
          @currentLine = @getCurrentLine()
          @lineNumber = 1
          @characterNumber = 0

      e::getCurrentLine = (e) ->
        t = undefined
        @currentLineMatcher.lastIndex = @bufferIndex + ((if e? then e else 0))
        t = @currentLineMatcher.exec(@buffer)
        (if t then t[0] else "")

      e::parseError = (e) ->
        haml.HamlRuntime.templateError @lineNumber, @characterNumber, @currentLine, e

      e::skipToEOLorEOF = ->
        e = undefined
        t = undefined
        n = undefined
        n = ""
        not @token.eof and not @token.eol and (@token.unknown or (n += @token.matched)
        @currentLineMatcher.lastIndex = @bufferIndex
        t = @currentLineMatcher.exec(@buffer)
        t and t.index is @bufferIndex and (e = (_.str or _).rtrim(t[0])
        (if (_.str or _).endsWith(e, "|") then (n += e.substring(0, e.length - 1)
        @advanceCharsInBuffer(e.length - 1)
        @getNextToken()
        n += @parseMultiLine()
        ) else (n += t[0]
        @advanceCharsInBuffer(t[0].length)
        @getNextToken()
        ))
        )
        )
        n

      e::parseMultiLine = ->
        e = undefined
        t = undefined
        n = undefined
        n = ""
        while @token.continueLine
          @currentLineMatcher.lastIndex = @bufferIndex
          t = @currentLineMatcher.exec(@buffer)
          t and t.index is @bufferIndex and (e = (_.str or _).rtrim(t[0])
          (_.str or _).endsWith(e, "|") and (n += e.substring(0, e.length - 1)
          @advanceCharsInBuffer(e.length - 1)
          )
          @getNextToken()
          )
        n

      e::advanceCharsInBuffer = (e) ->
        t = undefined
        n = undefined
        r = undefined
        r = 0
        while r < e
          t = @buffer.charCodeAt(@bufferIndex + r)
          n = @buffer.charCodeAt(@bufferIndex + r + 1)
          (if t is 13 and n is 10 then (@lineNumber++
          @characterNumber = 0
          @currentLine = @getCurrentLine(r)
          r++
          ) else (if t is 10 then (@lineNumber++
          @characterNumber = 0
          @currentLine = @getCurrentLine(r)
          ) else @characterNumber++))
          r++
        @bufferIndex += e

      e::currentParsePoint = ->
        lineNumber: @lineNumber
        characterNumber: @characterNumber
        currentLine: @currentLine

      e::pushBackToken = ->
        if not @token.unknown and not @token.eof
          @bufferIndex -= @token.matched.length
          @token = @prevToken

      e::isEolOrEof = ->
        @token.eol or @token.eof

      e
    ()
    e = ->
      e = (e) ->
        @generator = e
        @buffer = ""
        @outputBuffer = ""
      e::append = (e) ->
        @generator? and @buffer.length is 0 and @generator.mark()
        @buffer += e  if ((if e? then e.length else undefined)) > 0

      e::appendToOutputBuffer = (e) ->
        if ((if e? then e.length else undefined)) > 0
          @flush()
          @outputBuffer += e

      e::flush = ->
        e = undefined
        ((if (e = @buffer)? then e.length else undefined)) > 0 and (@outputBuffer += @generator.generateFlush(@buffer))
        @buffer = ""

      e::output = ->
        @outputBuffer

      e::trimWhitespace = ->
        e = undefined
        t = undefined
        if @buffer.length > 0
          t = @buffer.length - 1
          while t > 0
            e = @buffer.charAt(t)
            unless e is " " or e is "  " or e is "\n"
              break  if not (t > 1) or e isnt "n" and e isnt "t" or @buffer.charAt(t - 1) isnt "\\"
              t -= 2
          return @buffer = @buffer.substring(0, t + 1)  if t > 0 and t < @buffer.length - 1
          @buffer = ""  if t is 0

      e
    ()
    t = ->
      e = ->
      e::embeddedCodeBlockMatcher = /#{([^}]*)}/g
      e
    ()
    i = (e) ->
      t = ->
        @outputBuffer = new haml.Buffer(this)
      c(t, e)
      t::appendEmbeddedCode = (e, t, n, r, i) ->
        @outputBuffer.flush()
        @outputBuffer.appendToOutputBuffer(e + "try {\n")
        @outputBuffer.appendToOutputBuffer(e + "    var value = eval(\"" + (_.str or _).trim(t).replace(/"/g, "\\\"").replace(/\\n/g, "\\\\n") + "\");\n")
        @outputBuffer.appendToOutputBuffer(e + "    value = value === null ? \"\" : value;")
        (if n then @outputBuffer.appendToOutputBuffer(e + "    html.push(haml.HamlRuntime.escapeHTML(String(value)));\n") else (if r then @outputBuffer.appendToOutputBuffer(e + "    html.push(haml.HamlRuntime.perserveWhitespace(String(value)));\n") else @outputBuffer.appendToOutputBuffer(e + "    html.push(String(value));\n")))
        @outputBuffer.appendToOutputBuffer(e + "} catch (e) {\n")
        @outputBuffer.appendToOutputBuffer(e + "  throw new Error(haml.HamlRuntime.templateError(" + i.lineNumber + ", " + i.characterNumber + ", \"" + @escapeCode(i.currentLine) + "\",\n")
        @outputBuffer.appendToOutputBuffer(e + "    \"Error evaluating expression - \" + e));\n")
        @outputBuffer.appendToOutputBuffer(e + "}\n")

      t::initOutput = ->
        @outputBuffer.appendToOutputBuffer "  var html = [];\n  var hashFunction = null, hashObject = null, objRef = null, objRefFn = null;\n  with (context || {}) {\n"

      t::closeAndReturnOutput = ->
        @outputBuffer.flush()
        @outputBuffer.output() + "  }\n  return html.join(\"\");\n"

      t::appendCodeLine = (e, t) ->
        @outputBuffer.flush()
        @outputBuffer.appendToOutputBuffer(r.indentText(@indent))
        @outputBuffer.appendToOutputBuffer(e)
        @outputBuffer.appendToOutputBuffer(t)

      t::lineMatchesStartFunctionBlock = (e) ->
        e.match /function\s*\((,?\s*\w+)*\)\s*\{\s*$/

      t::lineMatchesStartBlock = (e) ->
        e.match /\{\s*$/

      t::closeOffCodeBlock = (e) ->
        if not e.token.minus or not e.matchToken(/\s*\}/g)
          @outputBuffer.flush()
          @outputBuffer.appendToOutputBuffer(r.indentText(@indent) + "}\n")

      t::closeOffFunctionBlock = (e) ->
        if not e.token.minus or not e.matchToken(/\s*\}/g)
          @outputBuffer.flush()
          @outputBuffer.appendToOutputBuffer(r.indentText(@indent) + "});\n")

      t::generateCodeForDynamicAttributes = (e, t, n, r, i, s) ->
        @outputBuffer.flush()
        r.length > 0 and (r = @replaceReservedWordsInHash(r)
        @outputBuffer.appendToOutputBuffer("    hashFunction = function () { return eval(\"hashObject = " + r.replace(/"/g, "\\\"").replace(/\n/g, "\\n") + "\"); };\n")
        )
        i.length > 0 and @outputBuffer.appendToOutputBuffer("    objRefFn = function () { return eval(\"objRef = " + i.replace(/"/g, "\\\"") + "\"); };\n")
        @outputBuffer.appendToOutputBuffer("    html.push(haml.HamlRuntime.generateElementAttributes(context, \"" + e + "\", [\"" + t.join("\",\"") + "\"], objRefFn, " + JSON.stringify(n) + ", hashFunction, " + s.lineNumber + ", " + s.characterNumber + ", \"" + @escapeCode(s.currentLine) + "\"));\n")

      t::replaceReservedWordsInHash = (e) ->
        t = undefined
        n = undefined
        r = undefined
        i = undefined
        s = undefined
        n = e
        s = ["class", "for"]

        r = 0
        i = s.length

        while r < i
          t = s[r]
          n = n.replace(t + ":", "\"" + t + "\":")
          r++
        n

      t::escapeCode = (e) ->
        e.replace(/\\/g, "\\\\").replace(/"/g, "\\\"").replace(/\n/g, "\\n").replace /\r/g, "\\r"

      t::generateJsFunction = (e) ->
        t = undefined
        try
          return new Function("context", e)
        catch n
          throw t = n
          "Incorrect embedded code has resulted in an invalid Haml function - " + t + "\nGenerated Function:\n" + e

      t::generateFlush = (e) ->
        "    html.push(\"" + @escapeCode(e) + "\");\n"

      t::setIndent = (e) ->
        @indent = e

      t::mark = ->

      t::appendTextContents = (e, t, n, r) ->
        not r? and (r = {})
        (if t and e.match(/#{[^}]*}/) then @interpolateString(e, n, r) else @outputBuffer.append(@processText(e, r)))

      t::interpolateString = (e, t, n) ->
        i = undefined
        s = undefined
        o = undefined
        u = undefined
        i = 0
        u = @embeddedCodeBlockMatcher.exec(e)

        while u
          u.index > 0 and (s = e.charAt(u.index - 1))
          u.index > 1 and (o = e.charAt(u.index - 2))
          (if s is "\\" and o isnt "\\" then (u.index isnt 0 and @outputBuffer.append(@processText(e.substring(i, u.index - 1), n))
          @outputBuffer.append(@processText(u[0]), n)
          ) else (@outputBuffer.append(@processText(e.substring(i, u.index)), n)
          @appendEmbeddedCode(r.indentText(@indent + 1), u[1], n.escapeHTML, n.perserveWhitespace, t)
          ))
          i = @embeddedCodeBlockMatcher.lastIndex
          u = @embeddedCodeBlockMatcher.exec(e)
        @outputBuffer.append @processText(e.substring(i), n)  if i < e.length

      t::processText = (e, t) ->
        (if ((if t? then t.escapeHTML else undefined)) then haml.HamlRuntime.escapeHTML(e) else (if ((if t? then t.perserveWhitespace else undefined)) then haml.HamlRuntime.perserveWhitespace(e) else e))

      t
    (t)
    s = (e) ->
      t = ->
        f = t.__super__.constructor.apply(this, arguments_)
        f
      c(t, e)
      t::appendEmbeddedCode = (e, t, n, r, i) ->
        @outputBuffer.flush()
        @outputBuffer.appendToOutputBuffer(e + "    value = " + (_.str or _).trim(t) + ";\n")
        @outputBuffer.appendToOutputBuffer(e + "    value = value === null ? \"\" : value;")
        (if n then @outputBuffer.appendToOutputBuffer(e + "    html.push(haml.HamlRuntime.escapeHTML(String(value)));\n") else (if r then @outputBuffer.appendToOutputBuffer(e + "    html.push(haml.HamlRuntime.perserveWhitespace(String(value)));\n") else @outputBuffer.appendToOutputBuffer(e + "    html.push(String(value));\n")))

      t::generateCodeForDynamicAttributes = (e, t, n, r, i, s) ->
        @outputBuffer.flush()
        r.length > 0 and (r = @replaceReservedWordsInHash(r)
        @outputBuffer.appendToOutputBuffer("    hashFunction = function () { return " + r + "; };\n")
        )
        i.length > 0 and @outputBuffer.appendToOutputBuffer("    objRefFn = function () { return " + i + "; };\n")
        @outputBuffer.appendToOutputBuffer("    html.push(haml.HamlRuntime.generateElementAttributes(context, \"" + e + "\", [\"" + t.join("\",\"") + "\"], objRefFn, " + JSON.stringify(n) + ", hashFunction, " + s.lineNumber + ", " + s.characterNumber + ", \"" + @escapeCode(s.currentLine) + "\"));\n")

      t::initOutput = ->
        @outputBuffer.appendToOutputBuffer "  var html = [];\n  var hashFunction = null, hashObject = null, objRef = null, objRefFn = null, value= null;\n  with (context || {}) {\n"

      t
    (i)
    n = (e) ->
      t = ->
        @outputBuffer = new haml.Buffer(this)
      c(t, e)
      t::appendEmbeddedCode = (e, t, n, r, i) ->
        s = undefined
        @outputBuffer.flush()
        s = @calcCodeIndent()
        @outputBuffer.appendToOutputBuffer(s + "try\n")
        @outputBuffer.appendToOutputBuffer(s + "  exp = CoffeeScript.compile('" + t.replace(/'/g, "\\'").replace(/\\n/g, "\\\\n") + "', bare: true)\n")
        @outputBuffer.appendToOutputBuffer(s + "  value = eval(exp)\n")
        @outputBuffer.appendToOutputBuffer(s + "  value ?= ''\n")
        (if n then @outputBuffer.appendToOutputBuffer(s + "  html.push(haml.HamlRuntime.escapeHTML(String(value)))\n") else (if r then @outputBuffer.appendToOutputBuffer(s + "  html.push(haml.HamlRuntime.perserveWhitespace(String(value)))\n") else @outputBuffer.appendToOutputBuffer(s + "  html.push(String(value))\n")))
        @outputBuffer.appendToOutputBuffer(s + "catch e \n")
        @outputBuffer.appendToOutputBuffer(s + "  throw new Error(haml.HamlRuntime.templateError(" + i.lineNumber + ", " + i.characterNumber + ", '" + @escapeCode(i.currentLine) + "',\n")
        @outputBuffer.appendToOutputBuffer(s + "    'Error evaluating expression - ' + e))\n")

      t::initOutput = ->
        @outputBuffer.appendToOutputBuffer "html = []\n"

      t::closeAndReturnOutput = ->
        @outputBuffer.flush()
        @outputBuffer.output() + "return html.join(\"\")\n"

      t::appendCodeLine = (e, t) ->
        @outputBuffer.flush()
        @outputBuffer.appendToOutputBuffer(@calcCodeIndent())
        @outputBuffer.appendToOutputBuffer((_.str or _).trim(e))
        @outputBuffer.appendToOutputBuffer(t)
        @prevCodeIndent = @indent

      t::lineMatchesStartFunctionBlock = (e) ->
        e.match /\) [\-=]>\s*$/

      t::lineMatchesStartBlock = (e) ->
        not 0

      t::closeOffCodeBlock = (e) ->
        @outputBuffer.flush()

      t::closeOffFunctionBlock = (e) ->
        @outputBuffer.flush()

      t::generateCodeForDynamicAttributes = (e, t, n, r, i, s) ->
        o = undefined
        @outputBuffer.flush()
        o = @calcCodeIndent()
        r.length > 0 and (r = @replaceReservedWordsInHash(r)
        @outputBuffer.appendToOutputBuffer(o + "hashFunction = () -> s = CoffeeScript.compile('" + r.replace(/'/g, "\\'").replace(/\n/g, "\\n") + "', bare: true); eval 'hashObject = ' + s\n")
        )
        i.length > 0 and @outputBuffer.appendToOutputBuffer(o + "objRefFn = () -> s = CoffeeScript.compile('" + i.replace(/'/g, "\\'") + "', bare: true); eval 'objRef = ' + s\n")
        @outputBuffer.appendToOutputBuffer(o + "html.push(haml.HamlRuntime.generateElementAttributes(this, '" + e + "', ['" + t.join("','") + "'], objRefFn ? null, " + JSON.stringify(n) + ", hashFunction ? null, " + s.lineNumber + ", " + s.characterNumber + ", '" + @escapeCode(s.currentLine) + "'))\n")

      t::replaceReservedWordsInHash = (e) ->
        t = undefined
        n = undefined
        r = undefined
        i = undefined
        s = undefined
        n = e
        s = ["class", "for"]

        r = 0
        i = s.length

        while r < i
          t = s[r]
          n = n.replace(t + ":", "'" + t + "':")
          r++
        n

      t::escapeCode = (e) ->
        t = undefined
        n = undefined
        r = undefined
        i = undefined
        s = undefined
        n = ""
        t = 0
        s = @embeddedCodeBlockMatcher.exec(e)

        while s
          s.index > 0 and (r = e.charAt(s.index - 1))
          s.index > 1 and (i = e.charAt(s.index - 2))
          (if r is "\\" and i isnt "\\" then (s.index isnt 0 and (n += @_escapeText(e.substring(t, s.index - 1)))
          n += @_escapeText("\\" + s[0])
          ) else (n += @_escapeText(e.substring(t, s.index))
          n += s[0]
          ))
          t = @embeddedCodeBlockMatcher.lastIndex
          s = @embeddedCodeBlockMatcher.exec(e)
        t < e.length and (n += @_escapeText(e.substring(t)))
        n

      t::_escapeText = (e) ->
        e.replace(/\\/g, "\\\\").replace(/'/g, "\\'").replace(/"/g, "\\\"").replace(/\n/g, "\\n").replace /(^|[^\\]{2})\\\\#{/g, "$1\\#{"

      t::generateJsFunction = (e) ->
        t = undefined
        n = undefined
        try
          return n = CoffeeScript.compile(e,
            bare: not 0
          )
          new Function(n)
        catch r
          throw t = r
          "Incorrect embedded code has resulted in an invalid Haml function - " + t + "\nGenerated Function:\n" + n

      t::generateFlush = (e) ->
        @calcCodeIndent() + "html.push('" + @escapeCode(e) + "')\n"

      t::setIndent = (e) ->
        @indent = e

      t::mark = ->
        @prevIndent = @indent

      t::calcCodeIndent = ->
        e = undefined
        t = undefined
        n = undefined
        i = undefined
        s = undefined
        o = undefined
        e = 0
        t = n = 0
        i = @indent

        while (if 0 <= i then n <= i else n >= i)
          e += 1  if ((if (s = @elementStack[t])? then s.block else undefined)) or ((if (o = @elementStack[t])? then o.fnBlock else undefined))
          t = (if 0 <= i then ++n else --n)
        r.indentText e

      t::appendTextContents = (e, t, n, r) ->
        i = undefined
        s = undefined
        if t and e.match(/#{[^}]*}/)
          @outputBuffer.flush()
          i = s = ""

          if (if r? then r.escapeHTML else undefined)
            i = "haml.HamlRuntime.escapeHTML("
            s = ")"
          else if (if r? then r.perserveWhitespace else undefined)
            i = "haml.HamlRuntime.perserveWhitespace("
            s = ")"
          return @outputBuffer.appendToOutputBuffer(@calcCodeIndent() + "html.push(" + i + "\"" + @escapeCode(e) + "\"" + s + ")\n")
        e = haml.HamlRuntime.escapeHTML(e)  if (if r? then r.escapeHTML else undefined)
        e = haml.HamlRuntime.perserveWhitespace(e)  if (if r? then r.perserveWhitespace else undefined)
        @outputBuffer.append e

      t
    (t)
    u =
      plain: (e, t, n, r) ->
        i = undefined
        s = undefined
        o = undefined
        s = 0
        o = e.length

        while s < o
          i = e[s]
          t.appendTextContents(n + i + "\n", not 0, r)
          s++
        not 0

      javascript: (e, t, n, r) ->
        i = undefined
        s = undefined
        o = undefined
        t.outputBuffer.append(n + "<script type=\"text/javascript\">\n")
        t.outputBuffer.append(n + "//<![CDATA[\n")

        s = 0
        o = e.length

        while s < o
          i = e[s]
          t.appendTextContents(n + i + "\n", not 0, r)
          s++
        t.outputBuffer.append(n + "//]]>\n")
        t.outputBuffer.append(n + "</script>\n")

      css: (e, t, n, r) ->
        i = undefined
        s = undefined
        o = undefined
        t.outputBuffer.append(n + "<style type=\"text/css\">\n")
        t.outputBuffer.append(n + "/*<![CDATA[*/\n")

        s = 0
        o = e.length

        while s < o
          i = e[s]
          t.appendTextContents(n + i + "\n", not 0, r)
          s++
        t.outputBuffer.append(n + "/*]]>*/\n")
        t.outputBuffer.append(n + "</style>\n")

      cdata: (e, t, n, r) ->
        i = undefined
        s = undefined
        o = undefined
        t.outputBuffer.append n + "<![CDATA[\n"
        s = 0
        o = e.length

        while s < o
          i = e[s]
          t.appendTextContents(n + i + "\n", not 0, r)
          s++
        t.outputBuffer.append n + "]]>\n"

      preserve: (e, t, n, r) ->
        t.appendTextContents e.join("\n") + "\n", not 0, r,
          perserveWhitespace: not 0


      escape: (e, t, n, r) ->
        i = undefined
        s = undefined
        o = undefined
        s = 0
        o = e.length

        while s < o
          i = e[s]
          t.appendTextContents(n + i + "\n", not 0, r,
            escapeHTML: not 0
          )
          s++
        not 0

    a.haml =
      compileHaml: (e) ->
        t = undefined
        n = undefined
        r = undefined
        return @_compileHamlTemplate(e, new haml.JsCodeGenerator)  if typeof e is "string"
        t = ->
          switch e.generator
            when "coffeescript"
              new haml.CoffeeCodeGenerator
            when "productionjavascript"
              new haml.ProductionJsCodeGenerator
            else
              new haml.JsCodeGenerator
        ()
        if e.source?
          r = new haml.Tokeniser(template: e.source)
        else unless e.sourceId?
          throw "No template source specified for compileHaml. You need to provide a source, sourceId or sourceUrl option"  unless e.sourceUrl?
          r = new haml.Tokeniser(templateUrl: e.sourceUrl)
        n = @_compileHamlToJs(r, t)
        (if e.outputFormat isnt "string" then t.generateJsFunction(n) else "function (context) {\n" + n + "}\n")

      compileCoffeeHaml: (e) ->
        @_compileHamlTemplate e, new haml.CoffeeCodeGenerator

      compileStringToJs: (e) ->
        t = undefined
        n = undefined
        t = new haml.JsCodeGenerator
        n = @_compileHamlToJs(new haml.Tokeniser(template: e), t)
        t.generateJsFunction(n)

      compileCoffeeHamlFromString: (e) ->
        t = undefined
        n = undefined
        t = new haml.CoffeeCodeGenerator
        n = @_compileHamlToJs(new haml.Tokeniser(template: e), t)
        t.generateJsFunction(n)

      compileHamlToJsString: (e) ->
        t = undefined
        t = "function (context) {\n"
        t += @_compileHamlToJs(new haml.Tokeniser(template: e), new haml.JsCodeGenerator)
        t += "}\n"

      _compileHamlTemplate: (e, t) ->
        n = undefined
        r = undefined
        haml.cache or (haml.cache = {})
        (if haml.cache[e] then haml.cache[e] else (r = @_compileHamlToJs(new haml.Tokeniser(templateId: e), t)
        n = t.generateJsFunction(r)
        haml.cache[e] = n
        n
        ))

      _compileHamlToJs: (e, t) ->
        n = undefined
        t.elementStack = []
        t.initOutput()
        e.getNextToken()

        until e.token.eof
          (if e.token.eol then (t.outputBuffer.append(e.token.matched)
          e.getNextToken()
          ) else (n = @_whitespace(e)
          t.setIndent(n)
          (if e.token.eol then (t.outputBuffer.append(r.indentText(n) + e.token.matched)
          e.getNextToken()
          ) else (if e.token.doctype then @_doctype(e, n, t) else (if e.token.exclamation then @_ignoredLine(e, n, t.elementStack, t) else (if e.token.equal or e.token.escapeHtml or e.token.unescapeHtml or e.token.tilde then @_embeddedJs(e, n, t.elementStack,
            innerWhitespace: not 0
          , t) else (if e.token.minus then @_jsLine(e, n, t.elementStack, t) else (if e.token.comment or e.token.slash then @_commentLine(e, n, t.elementStack, t) else (if e.token.amp then @_escapedLine(e, n, t.elementStack, t) else (if e.token.filter then @_filter(e, n, t) else @_templateLine(e, t.elementStack, n, t)))))))))
          ))
        @_closeElements(0, t.elementStack, e, t)
        t.closeAndReturnOutput()

      _doctype: (e, t, n) ->
        i = undefined
        s = undefined
        if e.token.doctype
          n.outputBuffer.append(r.indentText(t))
          e.getNextToken()
          e.token.ws and e.getNextToken()
          i = e.skipToEOLorEOF()

          if i and i.length > 0
            s = i.split(/\s+/)
            switch s[0]
              when "XML"
                (if s.length > 1 then n.outputBuffer.append("<?xml version='1.0' encoding='" + s[1] + "' ?>") else n.outputBuffer.append("<?xml version='1.0' encoding='utf-8' ?>"))
              when "Strict"
                n.outputBuffer.append "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">"
              when "Frameset"
                n.outputBuffer.append "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Frameset//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd\">"
              when "5"
                n.outputBuffer.append "<!DOCTYPE html>"
              when "1.1"
                n.outputBuffer.append "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">"
              when "Basic"
                n.outputBuffer.append "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML Basic 1.1//EN\" \"http://www.w3.org/TR/xhtml-basic/xhtml-basic11.dtd\">"
              when "Mobile"
                n.outputBuffer.append "<!DOCTYPE html PUBLIC \"-//WAPFORUM//DTD XHTML Mobile 1.2//EN\" \"http://www.openmobilealliance.org/tech/DTD/xhtml-mobile12.dtd\">"
              when "RDFa"
                n.outputBuffer.append "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML+RDFa 1.0//EN\" \"http://www.w3.org/MarkUp/DTD/xhtml-rdfa-1.dtd\">"
          else
            n.outputBuffer.append "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">"
          n.outputBuffer.append(@_newline(e))
          e.getNextToken()

      _filter: (e, t, n) ->
        r = undefined
        i = undefined
        s = undefined
        o = undefined
        if e.token.filter
          r = e.token.tokenString
          throw e.parseError("Filter '" + r + "' not registered. Filter functions need to be added to 'haml.filters'.")  unless haml.filters[r]
          e.skipToEOLorEOF()
          e.getNextToken()
          s = haml._whitespace(e)
          i = []

          while not e.token.eof and s > t
            o = e.skipToEOLorEOF()
            i.push(haml.HamlRuntime.indentText(s - t - 1) + o)
            e.getNextToken()
            s = haml._whitespace(e)
          haml.filters[r](i, n, haml.HamlRuntime.indentText(t), e.currentParsePoint())
          e.pushBackToken()

      _commentLine: (e, t, n, i) ->
        s = undefined
        o = undefined
        if e.token.comment
          e.skipToEOLorEOF()
          e.getNextToken()
          o = @_whitespace(e)

          while not e.token.eof and o > t
            e.skipToEOLorEOF()
            e.getNextToken()
            o = @_whitespace(e)
          e.pushBackToken()  if o > 0
        else if e.token.slash
          haml._closeElements(t, n, e, i)
          i.outputBuffer.append(r.indentText(t))
          i.outputBuffer.append("<!--")
          e.getNextToken()
          s = e.skipToEOLorEOF()
          s and s.length > 0 and i.outputBuffer.append(s)
          (if s and (_.str or _).startsWith(s, "[") and s.match(/\]\s*$/) then (n[t] =
            htmlConditionalComment: not 0
            eol: @_newline(e)

          i.outputBuffer.append(">")
          ) else n[t] =
            htmlComment: not 0
            eol: @_newline(e)
          )
          haml._tagHasContents(t, e) and i.outputBuffer.append("\n")
          e.getNextToken()

      _escapedLine: (e, t, n, i) ->
        s = undefined
        if e.token.amp
          haml._closeElements(t, n, e, i)
          i.outputBuffer.append(r.indentText(t))
          e.getNextToken()
          s = e.skipToEOLorEOF()
          s and s.length > 0 and i.outputBuffer.append(haml.HamlRuntime.escapeHTML(s))
          i.outputBuffer.append(@_newline(e))
          e.getNextToken()

      _ignoredLine: (e, t, n, i) ->
        s = undefined
        if e.token.exclamation
          e.getNextToken()
          e.token.ws and (t += haml._whitespace(e))
          haml._closeElements(t, n, e, i)
          s = e.skipToEOLorEOF()
          i.outputBuffer.append(r.indentText(t) + s)

      _embeddedJs: (e, t, n, i, s) ->
        o = undefined
        u = undefined
        a = undefined
        f = undefined
        l = undefined
        n and haml._closeElements(t, n, e, s)
        if e.token.equal or e.token.escapeHtml or e.token.unescapeHtml or e.token.tilde
          u = e.token.escapeHtml or e.token.equal
          l = e.token.tilde
          o = e.currentParsePoint()
          e.getNextToken()
          a = e.skipToEOLorEOF()
          f = r.indentText(t)
          (not i or i.innerWhitespace) and s.outputBuffer.append(f)
          s.appendEmbeddedCode(f, a, u, l, o)

          if not i or i.innerWhitespace
            s.outputBuffer.append @_newline(e)
            e.getNextToken()  if e.token.eol

      _jsLine: (e, t, n, r) ->
        i = undefined
        if e.token.minus
          haml._closeElements(t, n, e, r)
          e.getNextToken()
          i = e.skipToEOLorEOF()
          r.setIndent(t)
          r.appendCodeLine(i, @_newline(e))
          e.token.eol and e.getNextToken()

          return n[t] = fnBlock: not 0  if r.lineMatchesStartFunctionBlock(i)
          n[t] = block: not 0  if r.lineMatchesStartBlock(i)

      _templateLine: (e, t, n, i) ->
        s = undefined
        o = undefined
        u = undefined
        a = undefined
        f = undefined
        l = undefined
        c = undefined
        h = undefined
        p = undefined
        d = undefined
        v = undefined
        m = undefined
        g = undefined
        e.token.eol or @_closeElements(n, t, e, i)
        h = @_element(e)
        c = @_idSelector(e)
        u = @_classSelector(e)
        v = @_objectReference(e)
        s = @_attributeList(e)
        f = e.currentParsePoint()
        o = @_attributeHash(e)
        g =
          selfClosingTag: not 1
          innerWhitespace: not 0
          outerWhitespace: not 0

        d = @_lineHasElement(h, c, u)
        e.token.slash and (g.selfClosingTag = not 0
        e.getNextToken()
        )
        e.token.gt and d and (g.outerWhitespace = not 1
        e.getNextToken()
        )
        e.token.lt and d and (g.innerWhitespace = not 1
        e.getNextToken()
        )
        d and (g.selfClosingTag or (g.selfClosingTag = haml._isSelfClosingTag(h) and not haml._tagHasContents(n, e))
        @_openElement(f, n, h, c, u, v, s, o, t, g, i)
        )
        l = not 1
        e.token.ws and e.getNextToken()
        (if e.token.equal or e.token.escapeHtml or e.token.unescapeHtml then (@_embeddedJs(e, n + 1, null, g, i)
        l = not 0
        ) else (a = ""
        m = not 1
        (if e.token.exclamation then (e.getNextToken()
        a = e.skipToEOLorEOF()
        ) else (a = e.skipToEOLorEOF()
        a.match(/^\\/) and (a = a.substring(1))
        m = not 0
        ))
        l = a.length > 0
        l and ((if g.innerWhitespace and d or not d and haml._parentInnerWhitespace(t, n) then p = r.indentText((if h.length > 0 then n + 1 else n)) else (p = ""
        a = (_.str or _).trim(a)
        ))
        i.appendTextContents(p + a, m, f)
        i.outputBuffer.append(@_newline(e))
        )
        @_eolOrEof(e)
        ))

        throw haml.HamlRuntime.templateError(f.lineNumber, f.characterNumber, f.currentLine, "A self-closing tag can not have any contents")  if g.selfClosingTag and l

      _attributeHash: (e) ->
        t = undefined
        t = ""
        e.token.attributeHash and (t = e.token.tokenString
        e.getNextToken()
        )
        t

      _objectReference: (e) ->
        t = undefined
        t = ""
        e.token.objectReference and (t = e.token.tokenString
        e.getNextToken()
        )
        t

      _attributeList: (e) ->
        t = undefined
        n = undefined
        n = {}
        if e.token.openBracket
          e.getNextToken()
          until e.token.closeBracket
            t = haml._attribute(e)
            (if t then n[t.name] = t.value else e.getNextToken())

            if e.token.ws or e.token.eol
              e.getNextToken()
            else throw e.parseError("Expecting either an attribute name to continue the attibutes or a closing bracket to end")  if not e.token.closeBracket and not e.token.identifier
          e.getNextToken()
        n

      _attribute: (e) ->
        t = undefined
        n = undefined
        t = null
        if e.token.identifier
          n = e.token.tokenString
          e.getNextToken()
          haml._whitespace(e)

          throw e.parseError("Expected '=' after attribute name")  unless e.token.equal
          e.getNextToken()
          haml._whitespace(e)

          throw e.parseError("Expected a quoted string or an identifier for the attribute value")  if not e.token.string and not e.token.identifier
          t =
            name: n
            value: e.token.tokenString

          e.getNextToken()
        t

      _closeElement: (e, t, n, i) ->
        s = undefined
        o = undefined
        if t[e]
          i.setIndent(e)
          (if t[e].htmlComment then i.outputBuffer.append(r.indentText(e) + "-->" + t[e].eol) else (if t[e].htmlConditionalComment then i.outputBuffer.append(r.indentText(e) + "<![endif]-->" + t[e].eol) else (if t[e].block then i.closeOffCodeBlock(n) else (if t[e].fnBlock then i.closeOffFunctionBlock(n) else (s = not t[e].tagOptions or t[e].tagOptions.innerWhitespace
          (if s then i.outputBuffer.append(r.indentText(e)) else i.outputBuffer.trimWhitespace())
          i.outputBuffer.append("</" + t[e].tag + ">")
          o = not t[e].tagOptions or t[e].tagOptions.outerWhitespace
          haml._parentInnerWhitespace(t, e) and o and i.outputBuffer.append("\n")
          )))))
          t[e] = null
          i.mark()

      _closeElements: (e, t, n, r) ->
        i = undefined
        s = undefined
        i = t.length - 1
        s = []

        s.push @_closeElement(i--, t, n, r)  while i >= e
        s

      _openElement: (e, t, n, i, s, o, u, a, f, l, c) ->
        h = undefined
        p = undefined
        d = undefined
        h = (if n.length is 0 then "div" else n)
        p = @_parentInnerWhitespace(f, t)
        d = not l or l.outerWhitespace
        d or c.outputBuffer.trimWhitespace()
        t > 0 and p and d and c.outputBuffer.append(r.indentText(t))
        c.outputBuffer.append("<" + h)
        (if a.length > 0 or o.length > 0 then c.generateCodeForDynamicAttributes(i, s, u, a, o, e) else c.outputBuffer.append(r.generateElementAttributes(null, i, s, null, u, null, e.lineNumber, e.characterNumber, e.currentLine)))

        if l.selfClosingTag
          c.outputBuffer.append "/>"
          c.outputBuffer.append "\n"  if l.outerWhitespace
        else
          c.outputBuffer.append(">")
          f[t] =
            tag: h
            tagOptions: l


          c.outputBuffer.append "\n"  if l.innerWhitespace

      _isSelfClosingTag: (e) ->
        e is "meta" or e is "img" or e is "link" or e is "script" or e is "br" or e is "hr"

      _tagHasContents: (e, t) ->
        n = undefined
        (if t.isEolOrEof() then (n = t.lookAhead(1)
        n.ws and n.tokenString.length / 2 > e
        ) else not 0)

      _parentInnerWhitespace: (e, t) ->
        t is 0 or not e[t - 1] or not e[t - 1].tagOptions or e[t - 1].tagOptions.innerWhitespace

      _lineHasElement: (e, t, n) ->
        e.length > 0 or t.length > 0 or n.length > 0

      hasValue: (e) ->
        e? and e isnt not 1

      attrValue: (e, t) ->
        (if e is "selected" or e is "checked" or e is "disabled" then e else t)

      _whitespace: (e) ->
        t = undefined
        n = undefined
        r = undefined
        n = 0
        if e.token.ws
          t = 0
          r = e.token.tokenString

          while t < r.length
            (if r.charCodeAt(t) is 9 and t % 2 is 0 then n += 2 else n++)
            t++
          n = Math.floor((n + 1) / 2)
          e.getNextToken()
        n

      _element: (e) ->
        t = undefined
        t = ""
        e.token.element and (t = e.token.tokenString
        e.getNextToken()
        )
        t

      _eolOrEof: (e) ->
        return e.getNextToken()  if e.token.eol or e.token.continueLine
        throw e.parseError("Expected EOL or EOF")  unless e.token.eof

      _idSelector: (e) ->
        t = undefined
        t = ""
        e.token.idSelector and (t = e.token.tokenString
        e.getNextToken()
        )
        t

      _classSelector: (e) ->
        t = undefined
        t = []
        while e.token.classSelector
          t.push(e.token.tokenString)
          e.getNextToken()
        t

      _newline: (e) ->
        (if e.token.eol then e.token.matched else (if e.token.continueLine then e.token.matched.substring(1) else "\n"))

    a.haml.Tokeniser = o
    a.haml.Buffer = e
    a.haml.JsCodeGenerator = i
    a.haml.ProductionJsCodeGenerator = s
    a.haml.CoffeeCodeGenerator = n
    a.haml.HamlRuntime = r
    a.haml.filters = u
  ).call this

  #skip callbacks during  fast typing
  $.fn.haml = (str) ->
    html = haml.compileHaml(source: str)
    html = html()
    console.log html
    $(this).html html
) jQuery